<!DOCTYPE html>
<html>
<head>
  <title>Circle Pong</title>
  <!-- <script src="client.js"></script> -->
  
</head>
<body>
  <canvas id="canvas" style=""></canvas>
</body>
<!-- Jquery... -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>

<script src="/socket.io/socket.io.js"></script>
<script>

(function(){

// a hex string
function getRandomColor () {
  var out = '#';
  for (var i=0; i<6; i++){
    out += '0123456789abcdef'[Math.floor(Math.random()*16)];
  }
  return out;
}


var lastUpdateTime = (new Date()).getTime();

// maps player ids to their paddle objects
var others = {};

var socket = io();

var DELAY = 30;         // milliseconds to wait
// var FPS = 1000 / DELAY; // How many updates per second

var myId;

var hasBeenInitialized = false;

socket.on('initialized', function(initInfo){
  myId = initInfo.yourId;
  hasBeenInitialized = true;
  others = initInfo.otherPaddles;
  publishPaddleUpdate();
});

socket.on('player-disconnected', function(playerId) {
  console.log('socket '+myId+' sees player left: '+playerId);
  delete others[playerId];
  for (var id in others){
    console.log('id: ', id, 'obj: ', others[id]);
  }
});

socket.on('paddle-update', function(paddleInfo) {
  console.log('Received paddle update: ', paddleInfo);
  others[paddleInfo.playerId] = paddleInfo.paddle;
});

socket.on('ball-update', function(ballSnapshot) {
  ball.snapshot = ballSnapshot;
});

function publishPaddleUpdate () {

  var updateInfo = {
    playerId: myId, //socket.id,
    paddle: takePaddleSnapshot()
  };
  // console.log('publishing paddle update: ', updateInfo);
  socket.emit('paddle-update', updateInfo);
}

var W = 300, H = 300;

var TWO_PI = 2 * Math.PI;

var ball = {
  x: 0,
  y: 0,
  radius: 20,
  color: 'red',
  outlineColor: 'black',
  vAngle: 10,
  vMagnitude: 0.03
};

function takeBallSnapshot() {
  return {
    x: ball.x,
    y: ball.y,
    time: (new Date()).getTime(),
    vAngle: ball.vAngle,
    vMagnitude: ball.vMagnitude
  };
}

ball.snapshot = takeBallSnapshot();


var paddle = {
  angle: 0,
  trackRadius: 100,
  get x () {
    return this.trackRadius * Math.cos(this.angle);
  },
  get y () {
    return this.trackRadius * Math.sin(this.angle);
  },
  angularVelocity: 0,       // radians per second
  angularAcceleration: 0.001,  // radians per second ^ 2
  maxAngularVelocity: 0.01,   // radians Per 
  radius: 50,
  color: getRandomColor(),
  outlineColor: getRandomColor(),
  // speed: 0.03         // How fast it moves around the track
};

// For purely drawing purposes
function takePaddleSnapshot(){
  return {
    x: paddle.x,
    y: paddle.y,
    radius: paddle.radius,
    color: paddle.color,
    outlineColor: paddle.outlineColor,
  };
}

var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');

canvas.width = W;
canvas.height = H;

function drawCircle(circle){
  ctx.fillStyle = circle.color || 'black';

  ctx.beginPath()
  ctx.arc(circle.x + canvas.width/2, circle.y + canvas.height/2, circle.radius, 0, TWO_PI, false);
  ctx.fill();
  ctx.lineWidth = 5;
  ctx.strokeStyle = circle.outlineColor || 'black';

  ctx.stroke();
  ctx.closePath();
}

function redraw() {

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.beginPath();
  ctx.strokeStyle = 'black';
  ctx.strokeRect(0, 0, canvas.width, canvas.height);
  ctx.closePath();

  // if (mouseX !== null){
  //   console.log('drawing circle at mouse coords');
  //   drawCircle({
  //     x: mouseX,
  //     y: mouseY,
  //     radius: 5
  //   });
  // }

  for (var id in others){
    drawCircle(others[id]);
  }

  drawCircle(ball);
  drawCircle(paddle);
}

var leftPressed = false;
var rightPressed = false;
var mouseDown = false;
var mouseX = null;
var mouseY = null;

// TODO chain?
$(document).keydown(function(e){
  if (e.which === 37) {         // left arrow
    leftPressed = true;
  } else if (e.which === 39) {  // right arrow
    rightPressed = true;
  }
});

$(document).keyup(function(e){
  if (e.which === 37) {         // left arrow
    leftPressed = false;
  } else if (e.which === 39) {  // right arrow
    rightPressed = false;
  }
});

$('#canvas').mousedown(function(e){
  if (e.which === 1) {          // left click
    mouseDown = true;
  }
});

$('#canvas').mouseup(function(e){
  if (e.which === 1) {          // right click
    mouseDown = false;
    mouseX = null;
    mouseY = null;
  }
});

$(document).mousemove(function(e){
  if (mouseDown){
    mouseX = e.pageX - canvas.offsetLeft - canvas.width/2;
    mouseY = e.pageY - canvas.offsetTop - canvas.height/2;
  }
});


// TODO don't emit right in this function...?
// returns true if a collision occurred
function detectAndResolveCollision(){
  var diffX = paddle.x - ball.x;
  var diffY = paddle.y - ball.y;

  var distance = Math.sqrt(diffX*diffX + diffY*diffY);

  if (distance < (ball.radius + paddle.radius)){
    var overlap = ball.radius + paddle.radius - distance;

    var offsetX = overlap * -(diffX / distance);
    var offsetY = overlap * -(diffY / distance);

    ball.x += offsetX;
    ball.y += offsetY;

    var vx = ball.vMagnitude * Math.cos(ball.vAngle);
    var vy = ball.vMagnitude * Math.sin(ball.vAngle);

    var dot = diffX * vx + diffY * vy;
    
    if (dot > 0) {    // If ball is moving towards paddle
      var surfaceAngle = Math.PI/2 + Math.atan2(diffY, diffX);
      var returnAngle = 2*surfaceAngle - ball.vAngle;
      ball.vAngle = returnAngle;
    }
    return true;
  }
  return false;
}

//Simply calculates where the ball is needed
function update() {
  // delete others[undefined];   //hack - not sure why it's appearing
  for (var id in others){
    console.log(id, others[id]);
    // console.log(others[id]);
  }
  var curTime = (new Date()).getTime();
  var paddleDt = curTime - lastUpdateTime;
  lastUpdateTime = curTime;

  // Elapsed milliseconds
  var dt = (new Date()).getTime() - ball.snapshot.time;

  ball.x = ball.snapshot.x + ball.snapshot.vMagnitude * Math.cos(ball.snapshot.vAngle) * dt;
  ball.y = ball.snapshot.y + ball.snapshot.vMagnitude * Math.sin(ball.snapshot.vAngle) * dt;

  paddle.angle += paddle.angularVelocity * paddleDt;


  // var 

  if (leftPressed && !rightPressed){
    paddle.angularVelocity = Math.min(paddle.maxAngularVelocity, paddle.angularVelocity + paddle.angularAcceleration);
  } else if (rightPressed && !leftPressed) {
    paddle.angularVelocity = Math.max(-paddle.maxAngularVelocity, paddle.angularVelocity - paddle.angularAcceleration);
    
    // paddle.angle -= TWO_PI * paddle.speed;

  } else if (mouseX !== null && mouseY !== null) {
    var desiredAngle = Math.atan2(mouseY, mouseX);
    var sinDelta = Math.sin(desiredAngle - paddle.angle);
    if (sinDelta < 0) {
      paddle.angularVelocity = Math.max(-paddle.maxAngularVelocity, paddle.angularVelocity - paddle.angularAcceleration);
    } else if (sinDelta > 0) {
      paddle.angularVelocity = Math.min(paddle.maxAngularVelocity, paddle.angularVelocity + paddle.angularAcceleration);

    }

  } else {      // slow down
    if (paddle.angularVelocity > 0){
      paddle.angularVelocity = Math.max(0, paddle.angularVelocity - paddle.angularAcceleration);
    } else if (paddle.angularVelocity < 0){
      paddle.angularVelocity = Math.min(0, paddle.angularVelocity + paddle.angularAcceleration);

    }
  }
  publishPaddleUpdate();

  var collision = detectAndResolveCollision();
  if (collision){
    ball.snapshot = takeBallSnapshot();
    socket.emit('ball-update', ball.snapshot);
  }
}

setInterval(function(){
  if (hasBeenInitialized){
    update();
    redraw();
  }
}, DELAY)


})();

</script>

</html>
